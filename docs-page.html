<!DOCTYPE html>
<html lang="en"> 
<head>
    <title>Bloom Docs</title>
    
    <!-- Meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <meta name="description" content="Bloom Greenhouse Monitoring System Documentatio">
    <meta name="author" content="Xiaoying Riley at 3rd Wave Media">    
    <link rel="shortcut icon" href="favicon.ico"> 
    
    <!-- Google Font -->
    <link href="https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700&display=swap" rel="stylesheet">
    
    <!-- FontAwesome JS-->
    <script defer src="assets/fontawesome/js/all.min.js"></script>
    
    <!-- Plugins CSS -->
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.2/styles/atom-one-dark.min.css">

    <!-- Theme CSS -->  
    <link id="theme-style" rel="stylesheet" href="assets/css/theme.css">

</head> 

<body class="docs-page">    
    <header class="header fixed-top">	    
        <div class="branding docs-branding">
            <div class="container-fluid position-relative py-2">
                <div class="docs-logo-wrapper">
					<button id="docs-sidebar-toggler" class="docs-sidebar-toggler docs-sidebar-visible mr-2 d-xl-none" type="button">
	                    <span></span>
	                    <span></span>
	                    <span></span>
	                </button>
	                <div class="site-logo"><a class="navbar-brand" href="index.html"><img style="width:50px;" class="logo-icon mr-2" src="assets/images/bloom_simbolo.svg" alt="logo"><span class="logo-text"><span class="text-alt">BLOOM</span></span></a></div>    
                </div><!--//docs-logo-wrapper-->
	            <div class="docs-top-utilities d-flex justify-content-end align-items-center">
	
                <ul class="social-list list-inline mx-md-3 mx-lg-5 mb-0 d-none d-lg-flex">
                    <li class="list-inline-item"><a href="https://github.com/alexandrejflopes/bloom" target="_blank"><i class="fab fa-github fa-fw"></i></a></li>
		            </ul><!--//social-list-->
                <!-- <a href="https://themes.3rdwavemedia.com/bootstrap-templates/startup/coderdocs-free-bootstrap-4-documentation-template-for-software-projects/" class="btn btn-primary d-none d-lg-flex">Download</a> -->
	            </div><!--//docs-top-utilities-->
            </div><!--//container-->
        </div><!--//branding-->
    </header><!--//header-->
    
    <div class="docs-wrapper">
	    <div id="docs-sidebar" class="docs-sidebar">
		    <nav id="docs-nav" class="docs-nav navbar">
			    <ul class="section-items list-unstyled nav flex-column pb-3">
				    <li class="nav-item section-title"><a class="nav-link scrollto active" href="#bloom-intro"><span class="theme-icon-holder mr-2"><i class="fas fa-map-signs"></i></span>O que é a Bloom?</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#funcionalidades">Funcionalidades</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#personas">Personas</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#cenarios">Cenários</a></li>

				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#arquitetura"><span class="theme-icon-holder mr-2"><i class="fas fa-sitemap"></i></span>Arquitetura</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#aplicacao-externa">Aplicação externa</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#cluster-kafka">Cluster Kafka</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#microsservicos">Microsserviços</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#base-dados">Base de Dados</a></li>
            <li class="nav-item"><a class="nav-link scrollto" href="#frontend">Frontend</a></li>

				    <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#implementacao-desenvolvimento"><span class="theme-icon-holder mr-2"><i class="fas fa-code"></i></span>Implementação e Desenvolvimento</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#deployment">Deployment</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#executar">Executar localmente</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#workflow">Workflow</a></li>
				
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#apis"><span class="theme-icon-holder mr-2"><i class="fas fa-cogs"></i></span>APIs</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#endpoints">Endpoints</a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#operacoes"><span class="theme-icon-holder mr-2"><i class="fas fa-tools"></i></span>Operações</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#monitorizacao">Monitorização</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#testes">Testes</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#item"></a></li>
				    
            <li class="nav-item section-title mt-3"><a class="nav-link scrollto" href="#consideracoes-finais"><span class="theme-icon-holder mr-2"><i class="fas fa-tasks"></i></span>Considerações Finais</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#dificuldades">Dificuldades</a></li>
				    <li class="nav-item"><a class="nav-link scrollto" href="#trabalho-futuro">Trabalho futuro</a></li>
				    
			    </ul>

		    </nav><!--//docs-nav-->
	    </div><!--//docs-sidebar-->
	    <div class="docs-content">
		    <div class="container">
			    <article class="docs-article" id="bloom-intro">
				    <header class="docs-header">
					    <h1 class="docs-heading">O que é a Bloom? <span class="docs-time">Última atualização: 2021-06-29</span></h1>
					    <section class="docs-intro">
						    <p>A Bloom é um sistema com a temática de monitorização de várias estufas. As estufas consistem em ambientes muito
                controlados relativamente a várias variáveis, como temperatura e humidade. A Bloom permite a monitorização destes
                espaços utilizando uma variedade de sensores que detetam estas medidas na forma de páginas web que mostram em tempo
                real as condições atuais do espaço. Além disso, também é possível consultar-se um histórico, através de diferentes
                gráficos das variáveis medidas em cada espaço.
                </p>
                <p>Outro aspecto relevante são os alarmes, que são realizados em eventos quando as medidas ultrapassam os limites
                aceitáveis (definidos de antemão pelo utilizador). Quando estes alarmes surgem, as condições de ambiente que
                ultrapassaram os limites são automaticamente ajustadas para valores dentro do aceitável, através de ações desencadeadas
                (e simuladas) pelo sistema (interrupção da rega, ligação do ar condicionado, etc.).
                </p>
						</section><!--//docs-intro-->
											
						
				    </header>
          <section class="docs-section" id="funcionalidades">
						<h2 class="section-heading">Funcionalidades</h2>
            <ul>
              <li>Visualização em tempo real das medidas realizadas por sensores, nos espaços;</li>
              <li>Visualização de um histórico dessas medidas nos espaços, permitindo a visualização da evolução temporal das mesmas;</li>
              <li>Definição de limites mínimos e máximos para os valores de temperatura e humidade;</li>
              <li>Aparecimento de alarmes quando os sensores detetam valores fora dos limites aceitáveis;</li>
              <li>Após surgirem alarmes, os valores que ultrapassaram os limites aceitáveis são automaticamente ajustados para valores
                  dentro do aceitável (através de rega, aumento/diminuição da temperatura através do ar condicionado ou controlo de CO2).</li>
            </ul>                 
					</section><!--//section-->

          <section class="docs-section" id="personas">
            <h2 class="section-heading">Personas</h2>
            <div style="display: flex; justify-content: center;">
              <img class="figure-img img-fluid  rounded" style="width:500px;" src="assets/images/antonio.png" alt="antonio">
            </div>
            <p><strong>Idade:</strong> 56 anos</p>
            <p><strong>Género:</strong> Masculino</p>
            <p><strong>Localização:</strong> São Pedro do Sul, Portugal</p>
            <p><strong>Família:</strong> Casado, pai de três filhos</p>
            <p><strong>Educação:</strong> Ensino secundário</p>
            <p><strong>Tecnologia:</strong> Internet, redes sociais</p>
            <p><strong>Bio:</strong> O António é pai de três filhos. Atualmente, vive sozinho com a sua mulher, na sua quinta em São
              Pedro do Sul,
              distrito de Viseu. O António é conhecido pelos seus produtos biológicos, que saem diretamente da sua quinta para uma
              pequena loja, situada no centro de Viseu.</p>
            <p><strong>Objetivos:</strong> O António quer inovar a sua variedade de produtos, pelo que procura produzir rebentos, em
              grande escala - é
              uma produção barata mas que traz um grande lucro.
            <p><strong>Frustrações:</strong> Com o aumento do mercado de produtos biológicos, o António sente que não consegue
              acompanhar esse
              crescimento. Cada vez há mais variedade de produtos biológicos e grandes produções a fazerem concorrência, pelo que
              sente a necessidade de evoluir.</p>
            <p><strong>Como a Bloom pode ajudar:</strong> Com a Bloom, o António poderá entender como tratar das suas estufas e
              aprender quais as
              necessidades dos seus rebentos. Assim, vai conseguir, de forma bastante fácil, produzi-los em grande escala e
              vendê-los
              na sua loja, dando desta forma um enorme passo para acompanhar o crescimento do mercado de produtos biológicos.</p>
          
          </section>

          <section class="docs-section" id="cenarios">
            <h2 class="section-heading">Cenários</h2>
            <h3>Ver as condições de humidade, em tempo real</h3>
            <p><strong>Funcionalidade: </strong>como utilizador quero ver, em tempo real, quais as condições de humidade da minha
              estufa.</p>
            <p><strong>Cenário: </strong>Ver as condições de humidade em tempo real<br><u>Dado que</u> estou na home
              page<br><u>Então</u> vou poder observar quais as condições de humidade atuais, na minha estufa</p>
            
            <h3>Ver as condições de temperatura, em tempo real</h3>
            <p><strong>Funcionalidade: </strong>como utilizador quero ver, em tempo real, quais as condições de temperatura da minha
              estufa.</p>
            <p><strong>Cenário:</strong>Ver as condições de temperatura em tempo real<br><u>Dado que</u> estou na home
              page<br><u>Então</u> vou poder observar quais as condições de temperatura atuais, na minha estufa</p>
            
            <h3>Receber um aviso, quando as condições de humidade não estão aceitáveis</h3>
            <p><strong>Funcionalidade: </strong>como utilizador, vou receber um aviso quando as condições de humidade da minha
              estufa não são aceitáveis, de acordo com
              os devidos parâmetros.</p>
            <p><strong>Cenário:</strong>Receber um aviso, quando as condições de humidade não estão aceitáveis<br><u>Dado que</u>
              tenho a página web aberta no meu computador<br><u>Quando</u> os parâmetros de humidade deixam de estar dentro dos
              valores aceitáveis<br><u>Então</u> vou receber um alerta com essa informação</p>
            
            <h3>Receber um aviso, quando as condições de temperatura não estão aceitáveis</h3>
            <p><strong>Funcionalidade: </strong>como utilizador, vou receber um aviso quando as condições de temperatura da minha
              estufa não são aceitáveis, de acordo com
              os devidos parâmetros.</p>
            <p><strong>Cenário:</strong>Receber um aviso, quando as condições de temperatura não estão aceitáveis<br><u>Dado que</u>
              tenho a página web aberta no meu computador<br><u>Quando</u> os parâmetros de temperatura deixam de estar dentro dos
              valores aceitáveis<br><u>Então</u> vou receber um alerta com essa informação</p>
            
            <h3>Definir os limites aceitáveis de temperatura</h3>
            <p><strong>Funcionalidade: </strong>como utilizador quero definir os limites aceitáveis de temperatura para a minha
              estufa.</p>
            <p><strong>Cenário:</strong> Definir os limites aceitáveis de temperatura<br>
              <u>Dado que</u> estou na home page<br>
              <u>Quando</u> seleciono, na navbar, a tab “Configurações”<br>
              <u>E</u> seleciono a tab “temperatura”<br>
              <u>E</u> preencho o campo “Limite mínimo de temperatura”<br>
              <u>E</u> preencho o campo “Limite máximo de temperatura”<br>
              <u>E</u> seleciono “Confirmar”<br>
              <u>Então</u> os novos limites aceitáveis de temperatura ficam definidos.<br>
            </p>
            
            <h3>Definir os limites aceitáveis de humidade</h3>
            <p><strong>Funcionalidade: </strong>como utilizador quero definir os limites aceitáveis de humidade para a minha
              estufa.</p>
            <p><strong>Cenário:</strong> Definir os limites aceitáveis de humidade<br>
              <u>Dado que</u> estou na home page<br>
              <u>Quando</u> seleciono, na navbar, a tab “Configurações”<br>
              <u>E</u> seleciono a tab humidade<br>
              <u>E</u> preencho o campo “Limite mínimo de humidade<br>
              <u>E</u> preencho o campo “Limite máximo de humidade<br>
              <u>E</u> seleciono “Confirmar”<br>
              <u>Então</u> os novos limites aceitáveis de humidade ficam definidos.<br>
            </p>
          </section>
				
			    </article>
			    
			    <article class="docs-article" id="arquitetura">
				    <header class="docs-header">
					    <h1 class="docs-heading">Arquitetura</h1>
					    <section class="docs-intro">
						    <p>A arquitetura do sistema baseia-se na arquitetura dos Microsserviços e vai ao encontro do modelo Event Driven.</p>
                <div style="display: flex; justify-content: center;">
                  <img class="figure-img img-fluid  rounded" style="width:1000px;" src="assets/images/arquitetura.jpg" alt="arquitetura">
                </div>
                
              </section><!--//docs-intro-->
				    </header>
				     <section class="docs-section" id="aplicacao-externa">
						  <h2 class="section-heading">Aplicação externa</h2>
              <p>Aplicação externa em Java / Spring Boot (sensorsGenerator), responsável por criar e simular o comportamento de sensores
              virtuais. Esta aplicação produz, constantemente, novos dados para cada sensor e responde, de forma apropriada e real, a
              eventuais ações. Por exemplo, inicialmente são produzidos valores de humidade que vão sendo incrementados ao longo do
              tempo, sendo que se ocorrer a ação de iniciar uma rega, os mesmos valores irão começar a aumentar. No caso da
              temperatura, esta começa por ter variações mais ou menos aleatórias e se o ar condicionado for ligado, os valores
              começam a descer. Por sua vez, os valores de CO2 também apresentam um comportamento mais ou menos variante mas não
              dependem de ações.</p>
              <p>Existem, no total, 7 sensores, sendo eles:</p>
              <ul>
                <li>2 pares de sensores gerais (Temperatura e CO2), dispostos nos dois lados (Este e Oeste) da estufa;</li>
                <li>3 sensores de Humidade, um por tabuleiro, visto que plantas de um mesmo tabuleiro são todas iguais e partilham o mesmo
                solo.</li>
              </ul>
					  </section><!--//section-->
					
					<section class="docs-section" id="cluster-kafka">
            <h2 class="section-heading">Cluster Kafka</h2>
            <p>Existem 5 tópicos:</p>
            <strong>esp50-sensors-temperature</strong>
            <ul>
              <li>Produtor: aplicação externa que gera novos dados dos sensores (sensorsGenerator)</li>
              <li>Consumidor: aplicação responsável pela leitura e armazenamento dos novos dados (sensorsApp)</li>
            </ul>
            <strong>esp50-sensors-humidity</strong>
            <ul>
              <li>Produtor: aplicação externa que gera novos dados dos sensores (sensorsGenerator)</li>
              <li>Consumidor: aplicação responsável pela leitura e armazenamento dos novos dados (sensorsApp)</li>
            </ul>
            <strong>esp50-sensors-co2</strong>
            <ul>
              <li>Produtor: aplicação externa que gera novos dados dos sensores (sensorsGenerator)</li>
              <li>Consumidor: aplicação responsável pela leitura e armazenamento dos novos dados (sensorsApp)</li>
            </ul>
            <strong>esp50-sensors-actions</strong>
            <ul>
              <li>Produtor: aplicação responsável por publicar ações conforme as leituras (detectorApp)</li>
              <li>Consumidor: aplicação externa que gera novos dados dos sensores e que, perante determinada ação (rega, ligar o ar
                condicionado,
                etc.) vai fazer subir ou baixar os valores (sensorsGenerator)</li>
            </ul>
            <strong>esp50-alarms</strong>
            <ul>
              <li>Produtor: aplicação responsável por publicar ações conforme as leituras e também alarmes (detectorApp)</li>
              <li>Consumidor: aplicação que recebe o alarme do tópico e envia para a componente de apresentação (manageApp)</li>
            </ul>
					</section><!--//section-->
					
					<section class="docs-section" id="microsservicos">
            <h2 class="section-heading">Microsserviços</h2>
            <p>Correspondem a 3 diferentes aplicações, em Java / SpringBoot:</p>
            <ul>
              <li>Aplicação sensorsApp, responsável por ler valores dos sensores e os armazenar na base de dados, sendo a única aplicação
              a comunicar diretamente com a mesma. É uma aplicação com serviço REST, que expõe endpoints acedidos pelas outras duas
              aplicações.</li>
              <li>Aplicação detectorApp que funciona como um scheduler que vai chamar regularmente endpoints da sensorsApp para obter
              limites de excedidos ou não. Determina que ações tomar e publica-as no tópico esp50-sensors-actions e também desencadeia
              respetivos alarmes, que publica no tópico esp50-alarms. É adicionalmente responsável por receber novos limites para os
              sensores, através do seu serviço REST.</li>
              <li>Aplicação manageApp que é uma aplicação com serviço REST responsável por comunicar com a componente de
              apresentação/frontend. Recebe pedidos e eventuais ações dos utilizadores e comunica com as restantes duas aplicações, de
              modo a proporcionar os serviços necessários. Para além dos pedidos HTTP, tem também implementado um mecanismo de
              WebSockets, utilizado para enviar alarmes para o frontend.</li>
            </ul>
					</section><!--//section-->

          <section class="docs-section" id="base-dados">
            <h2 class="section-heading">Base de Dados</h2>
            <p>Implementada com InfluxDB (versão 1.8) e funciona como repositório de armazenamento do histórico de leituras dos
            sensores.</p>
            <h3>Modelo de Dados - Leituras de sensores</h3>
            <p>As informações de uma leitura de um sensor consistem nos seguintes parâmetros:</p>
            <ul>
              <li>sensorId : Integer</li>
              <li>dataType: String {Double}</li>
              <li>sensorType: String {Temperature, Humidity, CO2}</li>
              <li>unit: String {Celsius, Percentage, Parts per million}</li>
              <li>unitAbreviation: String {C, %, ppm}</li>
              <li>value: Double </li>
              <li>timestamp: Long</li>
            </ul>
            <p></p>
            <p><strong>Exemplo</strong></p>
            <div class="docs-code-block">
              <pre class="shadow-lg rounded"><code class="json hljs">
              {
                <span class="hljs-attr">"sensorId"</span>: <span class="hljs-string">0</span>,
                <span class="hljs-attr">"dataType"</span>: <span class="hljs-string">"Double"</span>,
                <span class="hljs-attr">"sensorType"</span>: <span class="hljs-string">"Temperature"</span>,
                <span class="hljs-attr">"unit"</span>: <span class="hljs-string">"Celsius"</span>,
                <span class="hljs-attr">"unitAbreviation"</span>: <span class="hljs-string">"C"</span>,
                <span class="hljs-attr">"value"</span>: <span class="hljs-string">22.0</span>,
                <span class="hljs-attr">"timestamp"</span>: <span class="hljs-string">12345678</span>,
              }
            </code></pre>
            </div>
          </section>

          <section class="docs-section" id="frontend">
            <h2 class="section-heading">Frontend</h2>
            <p>Desenvolvido em ReactJS e corresponde à componente responsável por apresentar os dados e receber interações dos
            utilizadores. Comunica exclusivamente com a aplicação do backend manageApp, enviando-lhe pedidos HTTP e recebendo
            respostas, e também através de WebSockets, para a receção de alarmes.</p>
          </section>
          <!--//section-->
			    </article><!--//docs-article-->
			    
			    
			    <article class="docs-article" id="implementacao-desenvolvimento">
				    <header class="docs-header">
					    <h1 class="docs-heading">Implementação e Desenvolvimento</h1>
					    <section class="docs-intro">
                <p>Após o levantamento de requisitos e estabelecimento de uma visão geral acerca do sistema a desenvolver, procedeu-se à
                escolha das tecnologias e ferramentas a utilizar. Deste modo, a nível de backend optou-se por implementar o sistema em
                Java usando a plataforma Spring Boot, dado que a mesma permite criar a base do projeto de forma rápida e eficiente e os
                membros do grupo já se encontravam familiarizados com esta framework. Visto que o sistema iria possuir diferentes
                responsabilidades e tarefas, foi adoptada a arquitetura de Microsserviços, de modo a permitir isolar e separar
                funcionalidades e também equipas de desenvolvimento. As diferentes aplicações possuem uma estrutura framework-based e
                comunicam entre si através de APIs. Uma melhor descrição acerca das suas interligações e responsabilidades de cada uma
                pode ser encontrada na secção referente à Arquitetura. A base de dados escolhida numa primeira etapa foi o MySQL, tendo
                sido substituído pelo InfluxDB após uma melhor reflexão e comparação dos benefícios de cada uma, tendo em conta os
                nossos objetivos e o tipo de dados. Relativamente ao frontend, também se optou por utilizar uma ferramenta que já nos
                era conhecida e que apresenta bastante benefícios, facilidade de uso e rapidez de desenvolvimento, que é o ReactJS. Para
                a parte de envio de mensagens, foi escolhido utilizar o sistema Kafka, que permite processar, assincronamente, fluxos de
                dados provenientes de diversas fontes e surge como uma mais valia quando integrado numa arquitetura de Microsserviços.</p>
						  </section><!--//docs-intro-->
				    </header>
          <section class="docs-section" id="deployment">
						<h2 class="section-heading">Deployment</h2>
            <p>Todos os serviços e módulos do sistema foram deloyed em duas máquinas virtuais (VMs) criadas para o efeito: uma para
            hospedar recursos gerais, como bases de dados, Kafka, etc, e outra para os nossos módulos, específicos do nosso sistema.</p>
            <p>Cada módulo descrito (microsserviços, Kafka, base de dados, etc.) anteriormente foi “empacotado” em containers Docker.
            Estes containers foram publicados num Docker Registry, a partir do qual foram instalados na VM para poderem ser
            executados. Cada container corre a respetiva aplicação numa porta específica, de forma a possibilitar a comunicação
            entre os serviços. Além da porta, e como as aplicações foram deployed numa VM, é importante que cada aplicação que
            precise de comunicar com outro módulo (base de dados, Kafka, outra aplicação, etc.) conheça o IP onde esse módulo está a
            correr, ou seja, o IP da VM onde foi instalado.</p>
            <p>De seguida, apresentam-se as portas que se encontram associadas a algumas das ferramentas anteriormente enumeradas, bem
            como as portas associadas às aplicações/microsserviços:</p>

            <div class="table-responsive my-4">
              <table class="table table-bordered table-dark">
                <thead>
                  <tr>
                    <th scope="col">Microsserviço / Componente</th>
                    <th scope="col">Porta</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td>sensorsGenerator</td>
                    <td>50090</td>
                  </tr>
                  <tr>
                    <td>sensorsApp</td>
                    <td>50080</td>
                  </tr>
                  <tr>
                    <td>detectorApp</td>
                    <td>50050</td>
                  </tr>
                  <tr>
                    <td>manageApp</td>
                    <td>50060</td>
                  </tr>
                  <tr>
                    <td>InfluxDB</td>
                    <td>8086</td>
                  </tr>
                  <tr>
                    <td>Kafka</td>
                    <td>9092</td>
                  </tr>
                  <tr>
                    <td>Frontend (webapp)</td>
                    <td>50030</td>
                  </tr>
                  <tr>
                    <td>Elastic Search</td>
                    <td>9200</td>
                  </tr>
                  <tr>
                    <td>Kibana</td>
                    <td>5601</td>
                  </tr>
                </tbody>
              </table>
            </div>
					</section><!--//section-->
					
					<section class="docs-section" id="executar">
            <h2 class="section-heading">Executar localmente</h2>
            <p>
                Embora as aplicações estejam instaladas numa VM, o seu desenvolvimento ocorreu nas máquinas pessoas dos elementos da
                equipa, de forma colaborativa (como detalhado na secção “Workflow”, abaixo) e, portanto, há diferenças em certas
                configurações. De seguida, seguem-se os passos que devem ser tomados para correr o sistema localmente:
            </p>
            <ol type="1">
              <li>Executar uma instância do Influx DB localmente. A forma mais fácil é instalar a <a href="https://hub.docker.com/_/influxdb" target="_blank">imagem Docker do InfluxDB</a> e executá-la
              na porta 8086. De notar que a versão do InfluxDB usada é a 1.8, pelo que a imagem Docker a instalar deverá ser a
              correspondente a essa versão. Isto pode ser feito com o comando: <code>docker pull influxdb:1.8</code></li>
              <li>Instalar e executar o cluster Kafka (ver mais <a href="https://kafka.apache.org/quickstart" target="_blank">aqui</a>). Para isso é necessário:
                <ol type="a">
                  <li>Inicializar o Zookeeper</li>
                  <li>Inicializar o servidor Kafka</li>
                  <li>Criar os tópicos mencionados anteriormente, com os nomes exatamente iguais</li>
                </ol>
              </li>
              <li>Em cada aplicação, comentar as linhas que referem pares IP-porta com o IP da VM e descomentar as linhas equivalentes,
              mas que, em vez do IP, têm “localhost”. Essas linhas encontram-se:
                <ol type="a">
                  <li>Em cada microsserviço Spring Boot:
                    <ol type="i">
                      <li>No ficheiro <code>application.properties</code> no diretório <code>src/main/resources</code></li>
                      <li>No ficheiro <code>Utils.java</code> no diretório <code>src/main/java/ua/p50/&lt;nome_aplicação&gt;/utils</code></li>
                    </ol>
                  </li>
                  <li>Na aplicação web (frontend), no ficheiro <code>urls.js</code> no diretório <code>src/variables</code></li>
                </ol>
              </li>
            </ol>
            <p><strong>Nota:</strong> ao abrir a webapp (frontend) é mostrado um formulário de autenticação. Este formulário é apenas demonstrativo do
            fluxo idealizado de interação com o utilizador uma vez que não foi implementada autenticação. Assim, quaisquer
            credenciais fornecidas irão levar o utilizador a aceder à plataforma, já que o formulário é estático até ao momento.</p>
					</section><!--//section-->
					
					<section class="docs-section" id="workflow">
						<h2 class="section-heading">Workflow</h2>
            <p>
              Antes de começar o desenvolvimento, a equipa concordou em adotar um workflow, de forma a que todos os membros estivessem
              sincronizados e pudessem ter uma visão concreta do estado de desenvolvimento, bem como garantir uma comunicação fluída.</p>
              <p>Como principal ferramenta de comunicação, a equipa adotou o Slack, devido a uma organização de mensagens por tópicos.
              Ainda na comunicação, contámos com uma pasta na Google Drive, para armazenar todos os documentos necessários, como
              brainstorming, resultados de reuniões, diagramas e outros; e ainda o Trello, de forma a atribuir tarefas aos elementos
              da equipa e ter visibilidade sobre o que está feito, o que ainda falta fazer e o que está em desenvolvimento e por que
              elementos da equipa.</p>
              <p>No que toca ao desenvolvimento propriamente dito, a equipa adotou como repositório o GitHub, onde está o código fonte do
              sistema, seguindo um desenvolvimento baseado no GitFlow Workflow: uso de branches sempre que necessário
              (funcionalidades, correções, testes, etc.) e pull requests para fomentar a revisão do código por outros elementos da
              equipa.
            </p>
            <h3>CI/CD</h3>
            <p>A equipa adotou ainda um fluxo de Continuous Integration e Continuous Delivery, de forma a garantir que todos os módulos
            eram integrados e testados com sucesso e detetar eventuais erros no processo, de forma a corrigi-los o mais rapidamente
            possível. Para isso, a equipa recorreu ao Jenkins, integrado com nosso repositório GitHub, criando um Jenkinsfile na
            raiz do repositório com os passos necessários para a compilação, testes e deployment, que vão ser executados numa
            pipeline Jenkins. Esta pipeline é detalhada mais a fundo na secção “Operações”.</p>
					</section><!--//section-->
			    </article><!--//docs-article-->
			    
			    <article class="docs-article" id="apis">
				    <header class="docs-header">
					    <h1 class="docs-heading">APIs</h1>
					    <section class="docs-intro">
                <p>As três aplicações do backend proporcionam serviço REST e comunicam através de APIs, com mensagens do tipo JSON. O
                frontend comunica apenas com com a aplicação manageApp, enviando-lhe pedidos HTTP (GET) e recebendo respostas. Esta, por sua
                vez, processa os pedidos invocando os seus próprios serviços ou serviços das outras duas aplicações.
                </p>
              </section><!--//docs-intro-->
				    </header>

            <section class="docs-section" id="endpoints">
              <h2 class="section-heading">Endpoints</h2>
              <code>/sensor/{id}/readings/latest</code>
              <p></p>
              <p>Permite obter a leitura de um dado sensor, identificado pelo seu ID, mais recente.</p>
              
              <code>/sensor/{id}/readings/all/{count}</code>
              <p></p>
              <p>Permite obter um determinado número de últimas leituras, ordenadas, de um dado sensor, identificado pelo seu ID. Se o
                número passado ultrapassar o número real de dados existentes na base de dados, são devolvidos apenas aqueles que
                definitivamente existem.
                Obter as leituras mais recentes de todos os sensores</p>
              
              <code>/sensor/all/latest-readings</code>
              <p></p>
              <p>Permite obter a leitura mais recente de todos os sensores que existem.</p>
              
              <code>/sensor/{type}/latest-readings</code>
              <p></p>
              <p>Permite obter a leitura mais recente de todos os sensores de um dado tipo.</p>
              
              <code>/sensor/{id}</code>
              <p></p>
              <p>Permite obter a informação ou características do sensor com esse ID.</p>
              
              <code>/sensor-limits/temperature/new?min=30&max=40</code>
              <p></p>
              <p>Permite definir novos limites para os sensores de temperatura.</p>
              
              <code>/sensor-limits/humidity/new?min=30&max=40</code>
              <p></p>
              <p>Permite definir os novos limites para os sensores de humidade.</p>
              
              <code>/sensor-limits/temperature</code>
              <p></p>
              <p>Permite obter os limites atuais dos sensores de temperatura.</p>
              
              <code>/sensor-limits/humidity</code>
              <p></p>
              <p>Permite obter os limites atuais dos sensores de humidade.</p>
            </section>
				    
			    </article><!--//docs-article-->
			    
			    <article class="docs-article" id="operacoes">
				    <header class="docs-header">
					    <h1 class="docs-heading">Operações</h1>
					    <section class="docs-intro">
                <p>Com a utilização do Jenkins foi possível realizar uma pipeline que automatiza o “build” do projeto, o seu teste e o seu
                “deployment” na máquina virtual.</p>
                <p>Isto foi possível criando uma pipeline nova no Jenkins e ligando essa pipeline ao repositório do projeto. Desta forma, a
                pipeline será definida pelo Jenkinsfile presente na raiz do repositório relativo ao projeto.</p>
                  <p>A pipeline definida tem as seguintes fases (stages):</p>
                  <ul>
                    <li><strong>Test:</strong> são executados os testes automáticos das várias aplicações do projeto</li>
                    <li><strong>Build:</strong> é realizada a fase “maven build” das aplicações, ou seja, são gerados os executáveis dos projetos.</li>
                    <li><strong>Deploy:</strong> é realizado o “deploy” dos artefactos das aplicações para o “artifactory”(JFrog):</li>
                    <li><strong>Build images:</strong> são criadas as imagens Docker relativas às várias aplicações do sistema;</li>
                    <li><strong>Publish images:</strong> são publicadas as imagens Docker criadas para o “Docker registry”</li>
                    <li><strong>Runtime Deployment:</strong> através de comandos SSH para a VM playground é realizado o “deployment” das imagens Docker criadas. Isto implica a eliminação de versões anteriores do sistema na VM, tal como a criação dos novos “containers” que serão utilizados. Para esta fase são necessárias as credenciais necessárias para aceder à VM playground através de comandos SSH.</li>
                  </ul>
                  
                  <p>Para que a pipeline seja executada e o sistema seja deployed caso a pipeline passe, é apenas necessário clicar em “Build
                  now” e aguardar o resultado da pipeline. Mais informação sobre o Jenkins pode ser encontrada no <a href="https://www.jenkins.io/" target="_blank">site oficial</a>.</p>
              </section><!--//docs-intro-->
				    </header>
				     <section class="docs-section" id="monitorizacao">
						<h2 class="section-heading">Monitorização</h2>
              <p>De forma a monitorizar o estado do sistema, recorremos, em primeiro lugar, aos outputs da pipeline do Jenkins. Além de
              indicar os erros que aconteceram, o Jenkins fornece ainda uma visão geral sobre as etapas, o tempo de execução de uma e
              se foi bem sucedida ou não.</p>
              <div style="display: flex; justify-content: center;">
                <img class="figure-img img-fluid  rounded" style="width:700px;" src="assets/images/pipeline.png" alt="pipeline">
              </div>
              <p></p>
              <p>Além disso, contamos ainda com o Portainer, para visualizar as imagens presentes na VM e verificar o estado de cada e os
              seus logs.</p>
              <div style="display: flex; justify-content: center;">
                <img class="figure-img img-fluid  rounded" style="width:1000px;" src="assets/images/portainer.png" alt="portainer">
              </div>
              <p></p>
              <p>Uma outra ferramenta de monitorização proposta foi o ELK, mas não tirámos proveito da ferramenta por questões que
              detalhamos na secção “Considerações Finais”.</p>
					</section><!--//section-->
					
					<section class="docs-section" id="testes">
						<h2 class="section-heading">Testes</h2>
            <p>Foram realizados vários testes de integração e funcionais de modo a verificar a funcionalidade do sistema desenvolvido,
            tendo em conta os diferentes cenários.</p>
            <ul>
              <li><strong>Testes ao serviço que acede à base de dados:</strong> Foram efetuados testes, com recurso a JUnit e Mockito, à classe responsável pelos serviços da aplicação, que acedem à base de dados e retornam os resultados pedidos. De modo a isolar dependências externas e testar a funcionalidade dos serviços foi feito Mock do InfluxDB. Foram testados os cenários para verificar se quando existem dados na base de dados estes são retornados e possuem os timestamps corretos e se os métodos responsáveis por retornar os resultados mais recentes também apresentam o comportamento correto.</li>
              <li><strong>Testes aos serviços que interagem com o Kafka:</strong> Os testes referentes à recepção de mensagens de tópicos Kafka pelo serviço consumidor da aplicação foram efetuados recorrendo ao JUnit e EmbeddedKafka. Foram escritos com recurso à ferramenta Cucumber e têm como principal objetivo verificar se as mensagens são corretamente consumidas e se, consequentemente, são também invocados os serviços corretos, nomeadamente o serviço responsável por introduzir os novos dados lidos na base de dados da aplicação. É adicionalmente verificado se os mesmos são definitivamente lá armazenados. Os três cenários definidos correspondem aos três tópicos, dos respetivos três sensores Temperatura, Humidade e Co2.</li>
              <li><strong>Testes funcionais:</strong> para realização destes testes, foi usado Cucumber (através  da ferramenta cucumber js), juntamente com Selenium (usando o chromedriver). Realizaram-se testes funcionais para os seguintes cenários:
                <ul>
                  <li>Login na Bloom</li>
                  <li>Leituras de temperatura na dashboard</li>
                  <li>Leituras de CO2 na dashboard</li>
                  <li>Leituras de humidade na dashboard</li>
                  <li>Definição com sucesso de limites de temperatura e humidade</li>
                  <li>Definição de uma temperatura acima do limite permitido (gera um alerta de erro)</li>
                </ul>
              </li>
            </ul>
            <p>Como mencionado anteriormente, os testes automáticos serão executados na pipeline, de forma a garantir que o sistema
            está correto e pronto para ser devidamente deployed.</p>
					</section><!--//section-->
					
			    </article><!--//docs-article-->
			    
			    
		        <article class="docs-article" id="consideracoes-finais">
				    <header class="docs-header">
					    <h1 class="docs-heading">Considerações Finais</h1>
					    <section class="docs-intro">
						</section><!--//docs-intro-->
				    </header>
				     <section class="docs-section" id="dificuldades">
						<h2 class="section-heading">Dificuldades</h2>
            <p>Relativamente ao ELK, não fomos capazes de o colocar a funcionar na íntegra, tendo sido esta a nossa falha principal.
            Apesar de termos todos os ficheiros e definições necessárias, bem como logs criados, estes não aparecem no Kibana. Isto
            poderá ser devido a algum problema da VM alheio a nós. De qualquer forma, não conseguimos avançar mais em tempo útil.</p>
					</section><!--//section-->
					
					<section class="docs-section" id="trabalho-futuro">
						<h2 class="section-heading">Trabalho futuro</h2>
            <ul>
              <li>Resolver as dificuldades
                <ul>
                  <li>Como trabalho futuro, pretendemos ter o ELK completamente funcional. Caso tal não seja possível, iremos optar por outra
                  ferramenta de logging.</li>
                </ul>
              </li>
              <li>Histórico de alarmes e ações desencadeadas no sistema</li>
              <li>Implementação de autenticação (frontend e backend)</li>
            </ul>
					</section><!--//section-->
				
			    </article><!--//docs-article-->
			    
			    <footer class="footer">
				    <div class="container text-center py-5">
					    <!--/* This template is free as long as you keep the footer attribution link. If you'd like to use the template without the attribution link, you can buy the commercial license via our website: themes.3rdwavemedia.com Thank you for your support. :) */-->
				        <small class="copyright">Designed with <i class="fas fa-heart" style="color: #fb866a;"></i> by <a class="theme-link" href="http://themes.3rdwavemedia.com" target="_blank">Xiaoying Riley</a> for developers</small>
				        <ul class="social-list list-unstyled pt-4 mb-0">
						        <li class="list-inline-item"><a href="https://github.com/alexandrejflopes/bloom" target="_blank"><i class="fab fa-github fa-fw"></i></a></li> 
				        </ul><!--//social-list-->
				    </div>
			    </footer>
		    </div> 
	    </div>
    </div><!--//docs-wrapper-->
    
   
       
    <!-- Javascript -->          
    <script src="assets/plugins/jquery-3.4.1.min.js"></script>
    <script src="assets/plugins/popper.min.js"></script>
    <script src="assets/plugins/bootstrap/js/bootstrap.min.js"></script>  
    
    
    <!-- Page Specific JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.8/highlight.min.js"></script>
    <script src="assets/js/highlight-custom.js"></script> 
    <script src="assets/plugins/jquery.scrollTo.min.js"></script>
    <script src="assets/plugins/lightbox/dist/ekko-lightbox.min.js"></script> 
    <script src="assets/js/docs.js"></script> 

</body>
</html> 

